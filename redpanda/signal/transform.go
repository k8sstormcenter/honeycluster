package main

import (
	"encoding/json"
	"strings"

	"github.com/redpanda-data/redpanda/src/transform-sdk/go/transform"
)

func main() {
	keysSet = make(map[string]struct{}, len(keys))
	for _, key := range keys {
		keysSet[key] = struct{}{}
	}
	transform.OnRecordWritten(doTransform)
}

var fieldsToRemove = []string{"pid", "tid", "auid", "uid", "exec_id", "parent_exec_id"}

type Message struct {
	Timestamp string                 `json:"timestamp"`
	Data      map[string]interface{} `json:",inline"`
}

// the following are all the keys generated by
// apt update
// apt install -y python3-pip
// pip3 install kubernetes
// this is a demo and because it creates so much noise, we filter it , you can still see it in all other topics
var keys = []string{
	"exec3dcadad895698940965ce0923977d4ff", "exec4abd0f984be603cb27b9652795f0898f", "exec82adccdcfde7cfe761b6db02198b3ba6", "exec9b9d0e26c3ff1f706a2fef6786f0a1d7", "exec9fa74e748cf08ab56d28420f189d65bb", "execa0c1a7ee57012e241ac204e411be0738", "execa3d6a223da7449ef0e0eb04422fa23da", "execb7149f188575528980608068575774f1", "execc4c49914c36b5a768be277365ca86e85", "execc6b935ba7043d7dfa66f5815c6cec99d", "execd6629707c2e612deaccc0931220d2c34", "execfa2e399cd1c48204c3a7a3802fc8f3c3", "execfca4e79619681b5bbaaccd8d46cf913a",
}
var keysSet map[string]struct{}

func removeTimeFields(obj interface{}) {
	switch v := obj.(type) {
	case map[string]interface{}:
		for key, value := range v {
			// If the key contains "time", delete it
			for _, field := range fieldsToRemove {
				if strings.EqualFold(key, field) {
					delete(v, key)
					break
				}
			}
			if strings.Contains(strings.ToLower(key), "time") {
				delete(v, key)
			} else {
				// If the value is a map or a slice, recursively remove time fields
				removeTimeFields(value)
			}
		}
	case []interface{}:
		for i := range v {
			removeTimeFields(v[i])
		}
	}
}

func doTransform(e transform.WriteEvent, w transform.RecordWriter) error {
	// Unmarshal the incoming message into a map
	var incomingMessage map[string]interface{}
	err := json.Unmarshal(e.Record().Value, &incomingMessage)
	if err != nil {
		return err
	}

	// Remove the time fields from the message
	removeTimeFields(incomingMessage)
	// Extract 3 fields from the JSON and concat them as key
	key := e.Record().Key

	if _, ok := keysSet[string(key)]; !ok {

		// Marshal the result back to JSON
		jsonData, err := json.Marshal(incomingMessage)
		if err != nil {
			return err
		}

		// Create a new record with the JSON data
		record := &transform.Record{
			Key:       []byte(key),
			Value:     jsonData,
			Offset:    e.Record().Offset,
			Timestamp: e.Record().Timestamp,
			Headers:   e.Record().Headers,
		}

		// Write the record to the destination topic
		err = w.Write(*record)
		if err != nil {
			return err
		}

	}

	return nil
}
